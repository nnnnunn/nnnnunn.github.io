[{"id":"2279e94af3046c332d621ae7956bf9e6","title":"快速排序入门（C语言学习笔记）","content":"快速排序思想介绍本来打算让文心一言写一下这一块内容的，但改了几次 prompt 都写不好，还是算了。\n排序算法有很多种，比如冒泡排序、选择排序、桶排序、归并排序等等，但这些排序没有一个敢在名字里宣称自己“快速”。那么我们可想而知，快速排序自然有他的奇特之处。在这里，我们先不研究凭啥快速排序能拿下“快速”的名号，我们来仔细看看他奇妙的思想。\n快速排序以分治思想为基础，分治是计算机解决问题（当然人也是）的一个重要手段。所以在介绍快速排序之前，我们要先简单了解一下分治思想。\n分治思想分治，也即“分而治之”。顾名思义，就是把一个问题拆解成几个小问题去解决。当一个任务过于复杂的时候，我们可以尝试对他进行拆解。拆解一遍不够，就再拆一遍，直到拆解出来的问题能够轻而易举地解决。举个例子，对一个数列进行排序，看起来确实很复杂，但我们可以把这个数列拆解成两个数列，将他们分别排序，再进行合并；拆解出来的两个数列再进行拆解，这个操作一直进行下去，最后就变成了两个数之间的比较，这就是分治思想在发挥作用（上面提到的这个想法其实是归并排序的思路）。\n需要注意的是，分治过程中，问题的形式一般不会发生变化，我们往往是在减小问题的规模（像上面这个例子，同样是对数列进行排序，但是数列的长度在不断减小，直到变成了两个数的比较，这个时候所谓的排序就变成了单纯的比较，这就是量变引起质变）。\n快速排序思想排序的目的是让整个数列变得有序，“有序”，也就是单调递增或者单调递减。这是很严格的结果，因为对于任意位置都需要满足“前一个数小于等于他”和“后一个数大于等于他”（以单调递增为例）。\n我们不妨尝试着把目光集中在整个数列中的一个数上。对于一个单调递增有序数列中的某个数来说，他左边的数都小于他，他右边的数都大于他。假如我们倒过来想呢？\n对于一个数列，我们研究它中间的某个数。如果这个数左边的数都比它小，而这个数右边的数都比它大，那么它就有可能是一个单调递增的数列。我们规定对于数列 ，假设其中间位置为  如果有 ，我们就称该数列具有性质 ，显然，性质  是数列单调递增的必要不充分条件。\n快速排序参考代码#include &lt;stdio.h&gt;  \n\n// 交换两个元素的位置  \nvoid swap(int* a, int* b) {  \n    int temp = *a; \n    *a = *b;  \n    *b = temp;  \n}  \n\n// 找到基准元素的正确位置  \nint partition(int arr[], int low, int high) {  \n    int pivot = arr[high];  // 选择数组的最后一个元素作为基准  \n    int i = (low - 1);  // 定义指向低位的指针i，初值为low-1  \n    for (int j = low; j &lt;= high - 1; j++) {  // 遍历数组，从低位到高位  \n        if (arr[j] &lt; pivot) {  // 如果当前元素小于基准  \n            i++;  // 将i指针后移一位  \n            swap(&amp;arr[i], &amp;arr[j]);  // 将arr[j]和arr[i]交换位置，保证比基准小的元素都在基准的左侧  \n        }  \n    }  \n    swap(&amp;arr[i + 1], &amp;arr[high]);  // 最后将基准元素放到正确的位置上  \n    return (i + 1);  // 返回基准的索引位置  \n}  \n\n// 递归实现快速排序  \nvoid quickSort(int arr[], int low, int high) {  \n    if (low &lt; high) {  // 如果低位不等于高位，说明还有待排序的元素  \n        int pi = partition(arr, low, high);  // 对数组进行分割，并得到基准的索引位置pi  \n        quickSort(arr, low, pi - 1);  // 对基准左边的部分进行递归排序  \n        quickSort(arr, pi + 1, high);  // 对基准右边的部分进行递归排序  \n    }  \n}  \n\nint main() {  \n    int arr[] = {10, 7, 8, 9, 1, 5};  // 定义待排序的数组  \n    int n = sizeof(arr) / sizeof(arr[0]);  // 计算数组的元素个数n  \n    quickSort(arr, 0, n - 1);  // 对数组进行快速排序  \n    printf(\"Sorted array: \");  // 打印排序结果的前缀  \n    for (int i = 0; i &lt; n; i++) {  // 遍历数组，逐个打印元素  \n        printf(\"%d \", arr[i]);  // 打印当前元素和一个空格  \n    }  \n    printf(\"\\n\");  // 打印换行符，结束输出  \n    return 0;  // 主函数返回0，表示程序正常结束  \n}\n\n","slug":"快速排序入门（C语言入门）","date":"2023-11-28T01:52:28.000Z","categories_index":"计算机科学与技术-C语言","tags_index":"快速排序","author_index":"氮氮NNU"},{"id":"da2d4c79bbf0ce3c865b47a4d64793f5","title":"建站日志","content":"您好，欢迎来到 NN 的知识分享站！我是 氮氮NNU。\n本网站基于 hexo 模型、Aurora 主题建立，在此感谢背后的开发者为我提供了优质的平台、节省了我在网站开发和维护上投入的时间和经历。\n本网站将专注于分享我在高中思想政治以及广义人文社科领域的学习感悟、思政课程设计过程和复盘。由于个人兴趣特色，本网站将同时更新计算机科学领域的相关内容。\n关于我的更多信息 请移步 About 页面。希望本网站能给您一个良好的阅读体验！\n","slug":"建站日志","date":"2023-10-11T14:59:05.000Z","categories_index":"网站建设","tags_index":"日志","author_index":"氮氮NNU"}]